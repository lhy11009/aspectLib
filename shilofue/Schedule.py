# -*- coding: utf-8 -*-
r"""Schedule tasks

This exports: 

  -

This depends on:

  -  

Examples of usage:

  - default usage:

        python -m 

descriptions
""" 
import sys, os, argparse
# import json, re
# import pathlib
# import subprocess
import numpy as np
# from matplotlib import cm
from matplotlib import pyplot as plt

# directory to the aspect Lab
ASPECT_LAB_DIR = os.environ['ASPECT_LAB_DIR']
RESULT_DIR = os.path.join(ASPECT_LAB_DIR, 'results')
# directory to shilofue
shilofue_DIR = os.path.join(ASPECT_LAB_DIR, 'shilofue')
# import utilities in subdirectiory
sys.path.append(os.path.join(ASPECT_LAB_DIR, 'utilities', "python_scripts"))
import Utilities

def Usage():
    print("\
(One liner description\n\
\n\
Examples of usage: \n\
\n\
  - default usage: \n\
\n\
        python -m \
        ")


class SCHEDULER():
    '''
    Class for scheduling task
    '''
    def __init__(self):
        '''
        Initiation
        '''
        self.local_tasks = []
        self.remote_tasks = []
        pass

    def add_task(self, new_task_entry, **kwargs):
        '''
        add a task
        Inputs:
            new_task_entry (list or str): new task(s) to add
            kwargs:
                remote(True or False): whether this is a remote command
        '''
        is_remote = kwargs.get('remote', False)
        if type(new_task_entry) is str:
            if is_remote:
                self.remote_tasks.append(new_task_entry)
            else:
                self.local_tasks.append(new_task_entry)
        elif type(new_task_entry) is list:
            for new_task in new_task_entry:
                assert(type(new_task) == str)
                if is_remote:
                    self.remote_tasks.append(new_task)
                else:
                    self.local_tasks.append(new_task)

    def __call__(self, o_dir):
        '''
        Prepare bash scripts and schedule
        Exports:
            a "local.sh" file - script for local tasks
            a "remote.sh" file - script for remote tasks
        '''
        assert(os.path.isdir(o_dir))
        local_sh_script = os.path.join(o_dir, "local.sh")
        remote_sh_script = os.path.join(o_dir, "remote.sh")
        if len(self.local_tasks) > 0:
            with open(local_sh_script, 'w') as fout:
                fout.write('#!/bin/bash\n# Local script generated by SCHEDULER')
                for task in self.local_tasks:
                    fout.write("\n")
                    fout.write("%s" % task)
        os.chmod(local_sh_script, 0o771)
        print("SCHEDULER: local script - %s  is generated" % local_sh_script)
        if len(self.remote_tasks) > 0:
            with open(remote_sh_script, 'w') as fout:
                fout.write('#!/bin/bash\n# Remote script generated by SCHEDULER')
                for task in self.remote_tasks:
                    fout.write("\n")
                    fout.write("%s" % task)
        print("SCHEDULER: remote script - %s is generated" % remote_sh_script)
        


def ScheduleTaskCase(case_dir, new_task_local):
    '''
    Schedule post-processing for a single case
    Inputs:
        case_dir(str): case directory
        new_task_local(str or list): new local tasks to be added
    '''
    o_dir = os.path.join(case_dir, 'scheduler_script')
    if(not os.path.isdir(o_dir)):
        os.mkdir(o_dir)
    Scheduler = SCHEDULER()
    Scheduler.add_task(new_task_local)
    Scheduler(o_dir)
    pass


def SomeFunction(foo):
    '''
    descriptions
    Inputs:
        -
    Returns:
        -
    '''
    pass


def main():
    '''
    main function of this module
    Inputs:
        sys.arg[1](str):
            commend
        sys.arg[2, :](str):
            options
    '''
    _commend = sys.argv[1]
    # parse options
    parser = argparse.ArgumentParser(description='Parse parameters')
    parser.add_argument('-i', '--inputs', type=str,
                        default='',
                        help='Some inputs')
    _options = []
    try:
        _options = sys.argv[2: ]
    except IndexError:
        pass
    arg = parser.parse_args(_options)

    # commands
    if (_commend in ['-h', '--help']):
        # example:
        Usage()
    elif _commend == 'foo':
        # example:
        SomeFunction('foo')
    else:
        # no such option, give an error message
        raise ValueError('No commend called %s, please run -h for help messages' % _commend)

# run script
if __name__ == '__main__':
    main()